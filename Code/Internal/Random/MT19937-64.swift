#if os(iOS) || os(OSX)
import Darwin
#else
import Glibc
#endif

let entropyCount: Int = 312
let mostSignificantBits: UInt = 0xFFFFFFFF80000000 // Most significant 33 bits
let leastSignificantBits: UInt = 0x7FFFFFFF // Least significant 31 bits

// The array for the state vector
private struct generated {
	static var memory = [UInt](repeating: 0, count: entropyCount)
}

var usedEntropyIndex: Int = entropyCount + 1

/**
Mersenne Twister, 64-bit (MT19937-64).

For more details, see the reference [C implementation](http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/C-LANG/mt19937-64.c) and [Wikipedia](https://en.wikipedia.org/wiki/MerseentropyCounte_Twister).

Swift syntax note: &* is unsafe multiplication with overflow.
*/
private struct MersenneTwister64 {
	private static var seeded: Bool {
		get {
			return usedEntropyIndex == entropyCount + 1 // usedEntropyIndex == entropyCount + 1 means generated.memory[entropyCount] needs to be (re)initialized
		}
	}

	fileprivate static func seed(_ seed: UInt) {
		generated.memory[0] = seed

		usedEntropyIndex = 1
		while usedEntropyIndex < entropyCount { defer { usedEntropyIndex += 1 }
			generated.memory[usedEntropyIndex] = (6364136223846793005 &* (generated.memory[usedEntropyIndex - 1] ^ (generated.memory[usedEntropyIndex - 1] >> 62)) + UInt(usedEntropyIndex))
		}
	}

	fileprivate static func seed(_ keys: [UInt]) {
		seed(UInt(19650218))

		var i: Int = 1, j: Int = 0
		for _ in 0 ..< (entropyCount > keys.count ? entropyCount : keys.count) {
			generated.memory[i] = (generated.memory[i] ^ ((generated.memory[i - 1] ^ (generated.memory[i - 1] >> 62)) &* 3935559000370003845)) + keys[j] + UInt(j) // non linear
			i += 1; j += 1

			if i >= entropyCount {
				generated.memory[0] = generated.memory[entropyCount - 1]
				i = 1
			}

			if j >= keys.count {
				j = 0
			}
		}

		for _ in 0 ..< entropyCount - 1 {
			generated.memory[i] = (generated.memory[i] ^ ((generated.memory[i - 1] ^ (generated.memory[i - 1] >> 62)) &* 2862933555777941757)) - UInt(i) // non linear
			i += 1

			if i >= entropyCount {
				generated.memory[0] = generated.memory[entropyCount - 1]
				i = 1
			}
		}

		generated.memory[0] = 1 << 63 // mostSignificantBits is 1; assuring non-zero initial array
	}

	fileprivate static func random(_ entropy: () -> [UInt]) -> UInt {
		var x: UInt

		struct mag01 {
			static let memory: [UInt] = [ 0, 0xB5026F5AA96619E9 ]
		}

		if usedEntropyIndex == entropyCount { // generate entropyCount words at one time
			if !seeded {
				seed(entropy())
			}

			let half = (entropyCount / 2)
			for i in 0 ..< entropyCount - half {
				x = (generated.memory[i] & mostSignificantBits) | (generated.memory[i + 1] & leastSignificantBits)
				generated.memory[i] = generated.memory[i + half] ^ (x >> 1) ^ mag01.memory[Int(x & 1)]
			}

			for i in (entropyCount - half) ..< (entropyCount - 1) {
				x = (generated.memory[i] & mostSignificantBits) | (generated.memory[i + 1] & leastSignificantBits)
				generated.memory[i] = generated.memory[i + (half - entropyCount)] ^ (x>>1) ^ mag01.memory[Int(x & 1)]
			}

			x = (generated.memory[entropyCount - 1] & mostSignificantBits) | (generated.memory[0] & leastSignificantBits)
			generated.memory[entropyCount - 1] = generated.memory[half - 1] ^ (x >> 1) ^ mag01.memory[Int(x & 1)]

			usedEntropyIndex = 0
		}

		x = generated.memory[usedEntropyIndex]
		usedEntropyIndex += 1

		x ^= (x >> 29) & 0x5555555555555555
		x ^= (x << 17) & 0x71D67FFFEDA60000
		x ^= (x << 37) & 0xFFF7EEE000000000
		x ^= (x >> 43)
		
		return x
	}
}

extension UInt {
	/**
	Provide a random number generated by MT19937-64.

	This function will automatically provide the initial seed, and provide any further entropy upon request.
	*/
	internal static func MT19937_64_random() -> UInt {
		struct local {
			static var initiated: Bool = false
			static var mutex: pthread_mutex_t = {
				var mutex = pthread_mutex_t()
				pthread_mutex_init(&mutex, nil)
				return mutex
			}()
		}

		pthread_mutex_lock(&local.mutex); defer { pthread_mutex_unlock(&local.mutex) }
		if !local.initiated {
			local.initiated = true

			MersenneTwister64.seed(Seed.generate())
		}

		return MersenneTwister64.random({
			return Seed.generate()
		})
	}
}
